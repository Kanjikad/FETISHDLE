<!DOCTYPE html>
<html lang="pt-br" data-theme="dark">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Fetishdle</title>
    <style>
      /* --- CORES E VARI√ÅVEIS --- */
      :root {
        --correct: #538d4e;
        --present: #b59f3b;
        --absent: #3a3a3c;
        --default-bg: #121213;
        --text-color: #ffffff;
        --border-color: #3a3a3c;
        --key-bg: #818384;
        --hint-bg: #2c2c2e;
        --hint-text: #4dbce9;
        --overlay-bg: rgba(0, 0, 0, 0.85);
      }

      [data-theme="light"] {
        --correct: #6aaa64;
        --present: #c9b458;
        --absent: #787c7e;
        --default-bg: #ffffff;
        --text-color: #000000;
        --border-color: #d3d6da;
        --key-bg: #d3d6da;
        --hint-bg: #f0f0f0;
        --hint-text: #0077cc;
        --overlay-bg: rgba(255, 255, 255, 0.9);
      }

      * {
        box-sizing: border-box;
      }

      body {
        background-color: var(--default-bg);
        color: var(--text-color);
        font-family: "Helvetica Neue", Arial, sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        margin: 0;
        height: 100dvh;
        overflow: hidden;
        transition: background-color 0.3s, color 0.3s;
      }

      /* --- CABE√áALHO --- */
      header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
        max-width: 600px;
        padding: 10px 20px;
        border-bottom: 1px solid var(--border-color);
        flex-shrink: 0;
      }

      h1 {
        margin: 0;
        font-size: clamp(18px, 4vw, 24px);
        letter-spacing: 2px;
      }

      .theme-btn {
        background: none;
        border: none;
        cursor: pointer;
        font-size: 24px;
        color: var(--text-color);
      }

      /* --- √ÅREA CENTRAL --- */
      #game-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        width: 100%;
        max-width: 600px;
        padding: 10px;
        overflow-y: auto;
        min-height: 0;
      }

      #hint-container {
        background-color: var(--hint-bg);
        padding: 8px 15px;
        border-radius: 8px;
        margin-bottom: 10px;
        text-align: center;
        font-size: 14px;
        width: 100%;
        border: 1px solid var(--border-color);
        flex-shrink: 0;
      }

      #hint-text {
        font-weight: bold;
        color: var(--hint-text);
      }

      #message-area {
        height: 20px;
        margin-bottom: 5px;
        font-weight: bold;
        font-size: 14px;
        text-align: center;
        flex-shrink: 0;
      }

      /* --- TABULEIRO --- */
      #game-board {
        display: grid;
        grid-gap: 5px;
        width: 100%;
        max-height: 100%;
        padding-bottom: 10px;
        align-content: center;

        /* CORRE√á√ÉO AQUI: Centraliza o grid horizontalmente se a palavra for curta */
        justify-content: center;
      }

      .tile {
        width: 100%;
        aspect-ratio: 1 / 1;
        /* N√£o precisamos mais de max-width aqui, o grid cuida disso, 
           mas mantemos por seguran√ßa */
        max-width: 50px;

        border: 2px solid var(--border-color);
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 20px;
        font-weight: bold;
        text-transform: uppercase;
        user-select: none;
        transition: transform 0.15s, border-color 0.15s, background-color 0.15s;
      }

      .tile.small-text {
        font-size: 16px;
      }
      .tile.tiny-text {
        font-size: 12px;
      }

      @media (max-width: 360px) {
        #game-board {
          grid-gap: 3px;
        }
        .tile {
          font-size: 16px;
          border-width: 1.5px;
        }
        .tile.small-text {
          font-size: 12px;
        }
        .tile.tiny-text {
          font-size: 10px;
        }
      }

      /* --- ANIMA√á√ïES --- */
      .pop {
        animation: pop 0.1s;
      }
      @keyframes pop {
        50% {
          transform: scale(1.1);
        }
      }

      .flip {
        transform: rotateX(90deg);
        transition: transform 0.15s ease-in;
        backface-visibility: hidden;
      }

      .shake {
        animation: shake 0.5s;
      }
      @keyframes shake {
        0%,
        100% {
          transform: translateX(0);
        }
        10%,
        30%,
        50%,
        70%,
        90% {
          transform: translateX(-4px);
        }
        20%,
        40%,
        60%,
        80% {
          transform: translateX(4px);
        }
      }

      .correct {
        background-color: var(--correct);
        border-color: var(--correct);
        color: white;
      }
      .present {
        background-color: var(--present);
        border-color: var(--present);
        color: white;
      }
      .absent {
        background-color: var(--absent);
        border-color: var(--absent);
        color: white;
      }

      /* --- TECLADO --- */
      #keyboard-container {
        width: 100%;
        max-width: 600px;
        padding: 5px;
        padding-bottom: max(10px, env(safe-area-inset-bottom));
        background-color: var(--default-bg);
        flex-shrink: 0;
      }

      .keyboard-row {
        display: flex;
        justify-content: center;
        margin-bottom: 5px;
        width: 100%;
      }

      .key {
        font-family: inherit;
        font-weight: bold;
        border: 0;
        margin: 0 2px;
        height: 50px;
        border-radius: 4px;
        cursor: pointer;
        user-select: none;
        background-color: var(--key-bg);
        color: var(--text-color);
        flex: 1;
        display: flex;
        justify-content: center;
        align-items: center;
        text-transform: uppercase;
        font-size: 13px;
        touch-action: manipulation;
      }

      @media (max-height: 650px) {
        .key {
          height: 42px;
          font-size: 12px;
        }
        #hint-container {
          padding: 4px 10px;
          font-size: 12px;
          margin-bottom: 5px;
        }
        h1 {
          font-size: 18px;
        }
      }

      .key:active {
        transform: scale(0.95);
      }
      .key-wide {
        flex: 1.5;
        font-size: 11px;
      }

      .key.correct {
        background-color: var(--correct);
        border-color: var(--correct);
      }
      .key.present {
        background-color: var(--present);
        border-color: var(--present);
      }
      .key.absent {
        background-color: var(--absent);
        border-color: var(--absent);
      }

      /* --- MODAL --- */
      #result-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: var(--overlay-bg);
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 100;
      }
      #result-content {
        text-align: center;
        padding: 30px;
        background-color: var(--default-bg);
        border-radius: 12px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        max-width: 90%;
        animation: slideUp 0.3s ease-out;
      }
      @keyframes slideUp {
        from {
          transform: translateY(20px);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }
      button.restart-btn {
        margin-top: 20px;
        padding: 15px 30px;
        background-color: var(--correct);
        color: white;
        border: none;
        font-weight: bold;
        font-size: 18px;
        cursor: pointer;
        border-radius: 50px;
      }
    </style>
  </head>
  <body>
    <header>
      <div></div>
      <h1>FETISHDLE</h1>
      <button class="theme-btn" onclick="toggleTheme()" id="theme-icon">
        ‚òÄÔ∏è
      </button>
    </header>

    <div id="game-container">
      <div id="message-area"></div>
      <div id="hint-container">DICA: <span id="hint-text">...</span></div>
      <div id="game-board"></div>
    </div>

    <div id="keyboard-container"></div>

    <div id="result-modal">
      <div id="result-content">
        <h2 id="modal-title">FIM DE JOGO</h2>
        <p id="modal-msg"></p>
        <button class="restart-btn" onclick="initGame()">
          JOGAR NOVAMENTE
        </button>
      </div>
    </div>

    <script>
      /* --- DADOS --- */
      const wordDatabase = [
        { word: "ORGY", hint: "Sexo em grupo" },
        { word: "FOOTFETISH", hint: "Podolatria: fetiche por p√©s" },
        { word: "VOYEURISM", hint: "Prazer em espiar outros transando" },
        { word: "CUCKOLD", hint: "Excita√ß√£o ao ver parceira com outro homem" },
        {
          word: "GANGBANG",
          hint: "Uma pessoa com m√∫ltiplos parceiros ao mesmo tempo",
        },
        { word: "SUBMISSION", hint: "Prazer em se submeter e obedecer" },
        {
          word: "DOMINATION",
          hint: "Prazer em comandar e controlar o parceiro",
        },
        { word: "BONDAGE", hint: "Amarrar com cordas, algemas ou restri√ß√µes" },
        { word: "SPANKING", hint: "Dar palmadas fortes na bunda para prazer" },
        { word: "PEGGING", hint: "Mulher penetrando o homem com strap-on" },
        { word: "ROLEPLAY", hint: "Fingir ser outros personagens ou cen√°rios" },
        {
          word: "EDGING",
          hint: "Levar ao limite do orgasmo e parar repetidamente",
        },
        { word: "FACESITTING", hint: "Sentar no rosto do parceiro para oral" },
        { word: "JOI", hint: "Ordens para se masturbar" },
        {
          word: "CHASTITY",
          hint: "Cinto ou gaiola para impedir ere√ß√£o e orgasmo",
        },
        { word: "DEGRADATION", hint: "Humilha√ß√£o verbal ou f√≠sica" },
        { word: "MASOCHISM", hint: "Prazer em receber dor ou sofrimento" },
        { word: "SADISM", hint: "Prazer em causar dor no parceiro" },
        { word: "FISTING", hint: "Inserir toda a m√£o na vagina ou √¢nus" },
        { word: "GOLDENSHOWER", hint: "Urinar no corpo do parceiro" },
        {
          word: "LATEX",
          hint: "Roupas justas de l√°tex para sensa√ß√£o de restri√ß√£o",
        },
        { word: "LEATHER", hint: "Fetiche por couro e roupas de couro" },
        { word: "PETPLAY", hint: "Fingir ser um pet como cachorro ou gato" },
        { word: "WAXPLAY", hint: "Pingar cera quente no corpo" },
        {
          word: "ASMR",
          hint: "Sons sussurrados er√≥ticos para relaxamento sensual",
        },
        { word: "SPH", hint: "Humilha√ß√£o por p√™nis pequeno" },
        { word: "EXHIBITIONISM", hint: "Mostrar o corpo nu em p√∫blico" },
      ];

      /* --- ESTADO DO JOGO --- */
      let currentWordObj = {};
      let currentWord = "";
      let currentRow = 0;
      let currentTile = 0;
      let isGameOver = false;
      let isAnimating = false;
      const maxGuesses = 6;

      const board = document.getElementById("game-board");
      const messageArea = document.getElementById("message-area");
      const hintText = document.getElementById("hint-text");
      const resultModal = document.getElementById("result-modal");
      const modalTitle = document.getElementById("modal-title");
      const modalMsg = document.getElementById("modal-msg");
      const keyboardContainer = document.getElementById("keyboard-container");
      const themeIcon = document.getElementById("theme-icon");

      function initGame() {
        currentRow = 0;
        currentTile = 0;
        isGameOver = false;
        isAnimating = false;
        messageArea.textContent = "";
        resultModal.style.display = "none";
        board.innerHTML = "";

        // --- L√ìGICA DE N√ÉO REPETI√á√ÉO ---

        // 1. Recupera as palavras j√° jogadas do localStorage
        let playedWords =
          JSON.parse(localStorage.getItem("fetishdle_history")) || [];

        // 2. Cria uma lista apenas com palavras que AINDA N√ÉO foram jogadas
        let availableWords = wordDatabase.filter(
          (item) => !playedWords.includes(item.word)
        );

        // 3. Se n√£o houver mais palavras dispon√≠veis (todas foram jogadas)
        if (availableWords.length === 0) {
          alert(
            "Parab√©ns! Voc√™ completou todas as palavras dispon√≠veis. O hist√≥rico ser√° reiniciado."
          );
          playedWords = []; // Limpa a mem√≥ria RAM
          localStorage.removeItem("fetishdle_history"); // Limpa o navegador
          availableWords = [...wordDatabase]; // Disponibiliza tudo novamente
        }

        // 4. Sorteia apenas entre as dispon√≠veis
        const randomIndex = Math.floor(Math.random() * availableWords.length);
        currentWordObj = availableWords[randomIndex];
        currentWord = currentWordObj.word.toUpperCase();

        // 5. Salva a palavra sorteada no hist√≥rico imediatamente
        playedWords.push(currentWordObj.word);
        localStorage.setItem("fetishdle_history", JSON.stringify(playedWords));

        // --- FIM DA L√ìGICA DE N√ÉO REPETI√á√ÉO ---

        hintText.textContent = currentWordObj.hint;

        const wordLength = currentWord.length;

        board.style.gridTemplateColumns = `repeat(${wordLength}, minmax(0, 50px))`;

        let tileClass = "tile";
        if (wordLength > 10) tileClass += " small-text";
        if (wordLength > 14) tileClass += " tiny-text";

        for (let i = 0; i < maxGuesses * wordLength; i++) {
          const tile = document.createElement("div");
          tile.className = tileClass;
          tile.setAttribute("id", `tile-${i}`);
          board.appendChild(tile);
        }

        createKeyboard();
      }

      function toggleTheme() {
        const html = document.documentElement;
        const current = html.getAttribute("data-theme");
        if (current === "dark") {
          html.setAttribute("data-theme", "light");
          themeIcon.textContent = "üåô";
        } else {
          html.setAttribute("data-theme", "dark");
          themeIcon.textContent = "‚òÄÔ∏è";
        }
      }

      function createKeyboard() {
        keyboardContainer.innerHTML = "";
        const layout = ["QWERTYUIOP", "ASDFGHJKL", "ZXCVBNM"];

        layout.forEach((rowStr, index) => {
          const rowDiv = document.createElement("div");
          rowDiv.className = "keyboard-row";

          rowStr.split("").forEach((char) => {
            const keyBtn = createKeyElement(char, char, false);
            rowDiv.appendChild(keyBtn);
          });
          if (index === 1) {
            const enterKey = createKeyElement("‚å´", "BACKSPACE", true);
            rowDiv.appendChild(enterKey);
          }

          const backKey = createKeyElement("ENTER", "ENTER", true);
          if (index === 2) {
            rowDiv.appendChild(backKey);
          }
          keyboardContainer.appendChild(rowDiv);
        });
      }

      function createKeyElement(display, value, isWide) {
        const btn = document.createElement("button");
        btn.textContent = display;
        btn.setAttribute("data-key", value);
        btn.className = isWide ? "key key-wide" : "key";
        btn.onclick = () => {
          if (value === "ENTER") handleInput("ENTER");
          else if (value === "BACKSPACE") handleInput("BACKSPACE");
          else handleInput(value);
        };
        return btn;
      }

      document.addEventListener("keydown", (e) => {
        const key = e.key.toUpperCase();
        if (key === "ENTER" || key === "BACKSPACE") handleInput(key);
        else if (/^[A-Z√á]$/i.test(key)) handleInput(key);
      });

      function handleInput(key) {
        if (isGameOver || isAnimating) return;
        if (key === "ENTER") checkRow();
        else if (key === "BACKSPACE") deleteLetter();
        else addLetter(key);
      }

      function addLetter(letter) {
        const wordLength = currentWord.length;
        if (currentTile < (currentRow + 1) * wordLength) {
          const tile = document.getElementById(`tile-${currentTile}`);
          tile.textContent = letter;
          tile.classList.add("pop");
          setTimeout(() => tile.classList.remove("pop"), 100);
          tile.style.borderColor = "var(--present)";
          currentTile++;
          if (messageArea.textContent) messageArea.textContent = "";
        }
      }

      function deleteLetter() {
        const wordLength = currentWord.length;
        if (currentTile > currentRow * wordLength) {
          currentTile--;
          const tile = document.getElementById(`tile-${currentTile}`);
          tile.textContent = "";
          tile.style.borderColor = "var(--border-color)";
          if (messageArea.textContent) messageArea.textContent = "";
        }
      }

      function checkRow() {
        const wordLength = currentWord.length;
        if (currentTile !== (currentRow + 1) * wordLength) {
          showMessage("Palavra incompleta!");
          shakeRow();
          return;
        }

        isAnimating = true;
        let guess = "";
        const startTileId = currentRow * wordLength;

        for (let i = 0; i < wordLength; i++) {
          guess += document.getElementById(
            `tile-${startTileId + i}`
          ).textContent;
        }

        const guessArray = guess.split("");
        const wordArray = currentWord.split("");
        const tileStatus = new Array(wordLength).fill("absent");

        for (let i = 0; i < wordLength; i++) {
          if (guessArray[i] === wordArray[i]) {
            tileStatus[i] = "correct";
            wordArray[i] = null;
            guessArray[i] = null;
          }
        }
        for (let i = 0; i < wordLength; i++) {
          if (guessArray[i] && wordArray.includes(guessArray[i])) {
            tileStatus[i] = "present";
            wordArray[wordArray.indexOf(guessArray[i])] = null;
          }
        }

        for (let i = 0; i < wordLength; i++) {
          const tile = document.getElementById(`tile-${startTileId + i}`);
          const letter = tile.textContent;
          const status = tileStatus[i];

          setTimeout(() => {
            tile.classList.add("flip");
          }, i * 100);

          setTimeout(() => {
            tile.classList.add(status);
            tile.classList.remove("flip");
            tile.style.borderColor = "";
            updateKeyboardColor(letter, status);

            if (i === wordLength - 1) {
              endTurnLogic(guess);
            }
          }, i * 100 + 250);
        }
      }

      function updateKeyboardColor(letter, status) {
        const keyBtn = document.querySelector(`button[data-key="${letter}"]`);
        if (!keyBtn) return;
        const currentClass = keyBtn.classList;
        if (status === "correct") {
          keyBtn.classList.remove("present", "absent");
          keyBtn.classList.add("correct");
        } else if (status === "present" && !currentClass.contains("correct")) {
          keyBtn.classList.remove("absent");
          keyBtn.classList.add("present");
        } else if (
          status === "absent" &&
          !currentClass.contains("correct") &&
          !currentClass.contains("present")
        ) {
          keyBtn.classList.add("absent");
        }
      }

      function endTurnLogic(guess) {
        isAnimating = false;
        if (guess === currentWord) {
          setTimeout(() => showResult("PARAB√âNS!", "Voc√™ acertou!"), 500);
          isGameOver = true;
        } else {
          if (currentRow >= maxGuesses - 1) {
            setTimeout(
              () => showResult("FIM DE JOGO", `A palavra era: ${currentWord}`),
              500
            );
            isGameOver = true;
          } else {
            currentRow++;
          }
        }
      }

      function shakeRow() {
        const wordLength = currentWord.length;
        const startTileId = currentRow * wordLength;
        for (let i = 0; i < wordLength; i++) {
          const tile = document.getElementById(`tile-${startTileId + i}`);
          tile.classList.add("shake");
          setTimeout(() => tile.classList.remove("shake"), 500);
        }
      }

      function showMessage(msg) {
        messageArea.textContent = msg;
        setTimeout(() => {
          if (!isGameOver) messageArea.textContent = "";
        }, 2000);
      }

      function showResult(title, text) {
        modalTitle.textContent = title;
        modalMsg.textContent = text;
        resultModal.style.display = "flex";
      }

      initGame();
    </script>
  </body>
</html>
